# 生产环境装配体汇总清单导出异常问题报告  
一、问题概述  
程序在测试环境中可正常导出多层级装配体的汇总清单（含顶层及深层子装配体数据，无乱码，统计准确），但部署至生产环境后，导出功能出现异常：仅生成顶层装配体数据，深层子装配体数据缺失，文件存在乱码，且统计总数与实际不符。  
二、环境信息对比  
| 环境项         | 测试环境（正常）                          | 生产环境（异常）                          |  
|--------------------|---------------------------------------------|---------------------------------------------|  
| 主机配置           | Mac mini M4芯片（24G内存）brParallel Desktop 虚拟机 | HP Victus主机（Intel Core i7芯片）           |  
| 操作系统           | Windows 11（虚拟机内运行）                    | Windows 10（断网环境）                       |  
| SolidWorks 版本    | SolidWorks 2019                             | SolidWorks 2019                             |  
| Excel 版本         | （未明确，推测为正常激活版）                 | Excel 2016（未激活版）                       |  
| 网络状态           | （未明确，推测可联网）                       | 断网                                         |  
三、复现步骤  
在生产环境中启动程序；  
选择包含深层子装配体的多层级装配体文件（非仅顶层结构）；  
执行“导出汇总清单”操作，生成Excel文件。  
四、问题现象详情  
数据完整性异常  
异常表现：导出的汇总清单中仅包含顶层装配体数据，深层子装配体的基础数据（如零部件信息）未体现（程序未按预期递归处理深层子装配体）；  
排除项：汇总清单中“属性‘是否组装’标记为‘是’的项目未显示”（此为符合设计预期的行为，非异常）。  
文件格式异常  
异常表现：导出的Excel文件中，除“代号”字段外，其他字段存在乱码。  
统计准确性异常  
异常表现：汇总清单中的“统计总数”与实际装配体总数量不符（因深层子装配体数据缺失，导致总数偏少）。  
五、预期结果 vs 实际结果  
| 维度         | 预期结果（测试环境表现）                          | 实际结果（生产环境表现）                          |  
|------------------|-----------------------------------------------------|-----------------------------------------------------|  
| 数据层级完整性   | 递归导出顶层及所有深层子装配体的基础数据（不含“是否组装=是”的子装配体本身，符合设计） | 仅导出顶层装配体数据，深层子装配体的基础数据完全缺失     |  
| 文件编码         | 无乱码，所有字段显示正常                             | 除“代号”外，其他字段存在乱码                         |  
| 统计总数         | 与实际装配体总数量一致（含深层子装配体中的零部件）     | 总数偏少（仅统计顶层装配体数据）                       |  
六、附加信息  
生产环境为断网环境，无法访问外部网络资源；  
生产环境使用的Excel 2016为未激活版本；  
测试环境与生产环境的SolidWorks版本均为2019（版本号一致）。





          

        
            
toolName: view_files
            
status: success
          
            
filePath: /Users/quzheng/Documents/ExportNestedBOM/src/Utils.bas
          
已阅读你在“生产环境中不能递归的问题.md”的记录。结合当前代码与环境差异，我给出系统性的原因分析与可落地的对策，先结论后细化。

结论优先级（按可能性排序）
1) 子装配工程图无法被定位，导致递归中断（最可能）
- 代码会在与顶层工程图同一文件夹下，按“[代号].slddrw”去寻找对应的子装配工程图；若找不到就跳过该分支，不再下钻，从而只剩顶层数据。参见<mcfile name="RecursiveProcessor.bas" path="/Users/quzheng/Documents/ExportNestedBOM/src/RecursiveProcessor.bas"></mcfile>中构造 childDrw 的逻辑。
- 生产环境常见触发原因：
  - 文件命名不一致：BOM中的“代号”列里包含“代号+空格+名称”等扩展文本，而真实工程图文件名只有“代号”；或代号中含有空格、中文括号、特殊符号等。
  - 文件位置不一致：子装配工程图不在顶层工程图同目录。
  - Windows 10 长路径问题：路径过长时，Dir$/FileExists 可能返回不存在，导致判断失败。

2) 汇总文件中文乱码（较大可能）
- 当前汇总用 HTML 写入，但用 VBA 的 Open 写文本默认是系统 ANSI 编码；文件里虽然写了<meta charset='utf-8'>，但内容不是 UTF-8，Excel 2016 常会按系统代码页解码，导致除了“代号”（多数是字母数字）以外的中文字段显示为乱码。参见<mcfile name="Utils.bas" path="/Users/quzheng/Documents/ExportNestedBOM/src/Utils.bas"></mcfile>的 WriteSummaryHtmlXls。

3) 装配层级过深或路径过长触发限制（中等可能）
- 递归深度默认最大 10 层（<mcfile name="Constants.bas" path="/Users/quzheng/Documents/ExportNestedBOM/src/Constants.bas"></mcfile>里有常量），极端情况下会提前停止。
- Windows 10 默认未开启长路径支持（MAX_PATH=260），深层目录/名称较长时，文件存在但 FileExists 返回 False。

4) 列头或“是否组装”判定在生产模板与测试模板存在差异（较小可能）
- 我们已做了模糊匹配并支持多语言，但生产模板若有新的命名（如“装配件/部件类型”等），也可能导致识别偏差。不过你的记录里已明确“‘是否组装’标记为‘是’的不显示为符合预期”，说明识别大概率是正常的。

对策与操作建议

一、快速排查（当天可做）
- 打开运行日志：同目录下“[装配体名称]_run.log”（由 <mcfile name="Utils.bas" path="/Users/quzheng/Documents/ExportNestedBOM/src/Utils.bas"></mcfile> 的 GetLogPathFromDrawing 生成）。搜索关键字：
  - “未找到子装配体工程图：xxx” 这能直接确认递归中断的根因。
- 现场抽检一个“未展开”的子装配体：
  - 检查该行的“代号”值，确认目录中是否存在“[代号].slddrw”。
  - 若 BOM 代号类似“AB-001 子装配”，实际文件名若为“AB-001 子装配.slddrw”，建议更名为“AB-001.slddrw”，或让我把代码改为兼容（见后文“代码级对策”）。
- 路径长度检查：把工程图目录临时移到盘符根部（例如 D:\BOMTest\），再次导出，看是否恢复递归。
- 乱码判断：若“代号”正常、中文列乱码，基本可确定是编码问题而非数据缺失。

二、环境与流程对策（不改代码也能缓解）
- 文件命名规范：
  - 子装配工程图与顶层放同目录；
  - 文件名使用“代号.slddrw”；若 BOM 代号中带空格及中文名称，请将工程图文件名改为空格前半段的代号（纯字母数字和-/_），与我们刚做的“ExtractPartCode”逻辑一致。
- 路径控制：
  - 尽量将工程目录放在较短路径；Windows 10 建议开启“长路径支持”（组策略或注册表 LongPathsEnabled=1），避免 FileExists 误判。
- Excel 乱码规避：
  - 在修复前，可临时改为用“另存为 CSV（UTF-8 带 BOM）”的方式打开；更推荐让我们把程序输出改为“UTF-8 带 BOM”或 XML 2003 格式，见下。

三、代码级对策（我可以为你实装）
- 强化子装配工程图定位策略（解决“只出顶层”的核心问题）：
  - 当“[代号].slddrw”找不到时，自动尝试：
    - ExtractPartCode(代号).slddrw（即提取空格前的字母数字和-/_作为候选）；
    - 在当前目录做模糊搜索（文件名以提取的代号开头）；
    - 可选：允许配置多个子目录搜索路径。
  - 将“未找到子装配工程图”的清单追加写入汇总表末尾，便于现场一次性补齐。
- 输出编码彻底修复（解决乱码）：
  - 将 WriteSummaryHtmlXls 改为使用 ADODB.Stream 以 UTF-8 with BOM 写出；
  - 或改为输出 Excel XML Spreadsheet 2003（.xml），对 Excel 2016/2019 兼容且无乱码。
- 可配置与健壮性：
  - 提供 MAX_RECURSION_DEPTH 配置项（默认 10，可调高）；
  - 扩充列头别名（尤其“是否组装/项目号”等），进一步提高模板兼容性；
  - 在日志中打印子装配定位的候选路径与最终选择，便于问题复盘。

四、建议的最小改动组合
- 先做“子装配定位增强 + UTF-8 BOM 输出”这两项，基本可同时解决“只出顶层数据”和“乱码”两类问题，工作量小、见效快。
- 如你同意，我可以直接在以下位置实施：
  - 在<mcfile name="RecursiveProcessor.bas" path="/Users/quzheng/Documents/ExportNestedBOM/src/RecursiveProcessor.bas"></mcfile>里：当 FileExists(childDrw) = False 时，增加基于 ExtractPartCode 的候选名与模糊搜索逻辑，并记录缺失清单。
  - 在<mcfile name="Utils.bas" path="/Users/quzheng/Documents/ExportNestedBOM/src/Utils.bas"></mcfile>里：将 WriteSummaryHtmlXls 改为 UTF-8 BOM 写出（保留现有 HTML 结构不变）。

五、后续验证建议
- 用生产环境中的一个两层小装配（确保子装配的工程图在同目录）先验证递归是否正常；
- 再用真实大装配验证总数是否恢复准确、乱码是否消除；
- 若日志仍出现大量“未找到子装配工程图”，优先按清单补齐工程图或放宽搜索路径策略。

如果你确认我可以直接修改代码，我会用于：
- 增强子装配工程图定位（多策略备选与日志清单）；
- 将汇总输出改为 UTF-8 BOM，彻底修复乱码。
同时我会保持改动最小，避免影响你已验证通过的其他逻辑。
